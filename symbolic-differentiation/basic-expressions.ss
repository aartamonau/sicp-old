(module basic-expressions scheme
  (require "variable.ss")
  (provide make-sum sum? addend augend
           make-product product? multiplier multiplicand
           make-exponentiation exponentiation? base exponent)

  (define (=number? exp num)
    (and (number? exp)
         (= exp num)))
  (define (<number? exp num)
    (and (number? exp)
         (< exp num)))
  (define (<=number? exp num)
    (and (number? exp)
         (<= exp num)))

  (define (passes-sanity-test? items)
      (eq? (memf (lambda (x) (not (or (number? x)
                                      (symbol? x)
                                      (sum? x)
                                      (product? x)
                                      (exponentiation? x))))
                 items)
           #f))

  (define (split-list matches? items)
    (foldl (lambda (item current-result)
             (let ((true-items (car current-result))
                   (false-items (cadr current-result)))
               (if (matches? item)
                   (list (cons item true-items)
                         false-items)
                   (list true-items
                         (cons item false-items)))))
           (list '() '())
           items))

  ;; collects all identical elements into one pair (element, count)
  (define (collect-items identical? less-than? items)
    (define (helper previous count current-result sorted-items)
      (if (null? sorted-items)
          (cons (cons previous count) current-result)
          (let ((head (car sorted-items))
                (tail (cdr sorted-items)))
            (if (identical? previous head)
                (helper previous (+ count 1) current-result tail)
                (helper head 1 (cons (cons previous count) current-result) tail)))))
    (if (null? items)
        '()
        (let ((sorted (sort items less-than?)))
          (helper (car sorted) 1 '() (cdr sorted)))))

  (define (expr->string expr)
    (cond ((null? expr) "")
          ((symbol? expr) (symbol->string expr))
          ((number? expr) (number->string expr))
          ((list? expr) (string-append "("
                                       (substring (foldl (lambda (x prefix)
                                                           (string-append prefix " " (expr->string x)))
                                                         ""
                                                         expr)
                                                  1)
                                       ")"))
          (else (error "Invalid type of expression. [expr->string]"))))

  (define (expr=? x y)
    (string=? (expr->string x)
              (expr->string y)))

  (define (expr<=? x y)
    (string<=? (expr->string x)
               (expr->string y)))

  ;; collects numbers and expressions if possible
  ;; in the simpliest case comparison operations define only symblo-to-symbol comparisons
  ;; in more complex case those can analize the structure of expressions
  (define (commutative-operation-collect numbers-collector initial-number
                                         expr-equal? expr-less-than? expr-transform
                                         operation-symbol)
    (lambda (x y rest)
      (let ((items (cons x (cons y rest))))
        (if (passes-sanity-test? items)
            (let* ((splited (split-list number? items))
                   (numbers (car splited))
                   (expressions (cadr splited))
                   (folded-numbers (foldl numbers-collector initial-number numbers))
                   (collected-expressions (collect-items expr-equal? expr-less-than? expressions))
                   (post-processed-expressions (map (lambda (item)
                                                      (let ((expression (car item))
                                                            (count (cdr item)))
                                                        (expr-transform count expression)))
                                                    collected-expressions)))
              (cond ((null? post-processed-expressions) folded-numbers)
                    ((and (= folded-numbers initial-number)
                          (not (= (length post-processed-expressions) 1)))
                     (cons operation-symbol post-processed-expressions))
                    ((and (= folded-numbers initial-number)
                          (= (length post-processed-expressions) 1))
                     (car post-processed-expressions))
                    (else (cons operation-symbol (cons folded-numbers post-processed-expressions)))))
            (error "Unknown element found. [commutative-operation-collect]")))))

  (define (make-sum x y . rest)
    ((commutative-operation-collect + 0
                                    expr=?
                                    expr<=?
                                    make-product
                                    '+)
     x y rest))

;;   (define (make-sum x y . rest)
;;     (let ((items (cons x (cons y rest))))
;;       (if (passes-sanity-test? items)
;;           (let* ((splited (split-list number? items))
;;                  (numbers (car splited))
;;                  (symbols (cadr splited))
;;                  (sum-of-numbers (foldl + 0 numbers))
;;                  (collected-symbols (collect-items (lambda (x y) (string=? (symbol->string x) (symbol->string y)))
;;                                                    (lambda (x y) (string<=? (symbol->string x) (symbol->string y)))
;;                                                    symbols))
;;                  (post-processed-symbols (map (lambda (item)
;;                                                 (let ((symbol (car item))
;;                                                       (count (cdr item)))
;;                                                   (make-product count symbol)))
;;                                               collected-symbols)))
;;             (if (= sum-of-numbers 0)
;;                 (cons '+ post-processed-symbols)
;;                 (cons '+ (cons sum-of-numbers post-processed-symbols))))
;;           (error "Undefined element found. [make-sum]"))))
             
  (define (sum? x)
    (and (pair? x)
         (eq? (car x) '+)))
  (define (addend s) (cadr s))
  (define (augend s) (caddr s))

  (define (make-product x y)
    (cond ((or (=number? x 0) (=number? y 0)) 0)
          ((=number? x 1) y)
          ((=number? y 1) x)
          ((and (number? x) (number? y)) (* x y))
          (else (list '* x y))))
  (define (product? x)
    (and (pair? x)
         (eq? (car x) '*)))
  (define (multiplier p) (cadr p))
  (define (multiplicand p) (caddr p))

  (define (make-exponentiation b e)
    (cond ((and (=number? b 0) (<=number? e 0) (error "Undefined value. (0 ^ (<=0))")))
          ((=number? b 0) 0)
          ((=number? b 1) 1)
          ((=number? e 0) 1)
          ((=number? e 1) b)
          ((and (number? b) (number? e) (expt b e)))
          (else (list '^ b e))))
  (define (exponentiation? x) (eq? (car x) '^))
  (define (base e) (cadr e))
  (define (exponent e) (caddr e)))


