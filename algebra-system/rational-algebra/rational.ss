;; SICP example.
;; Chapter 2.1.1
;; Rational numbers' computation system.
;; Changed in conforming to exercise 2.1

(module rational scheme
  (require "../tag-system/tag-system.ss" "../operations-table/operations-table.ss")
  (provide install-rational-package)

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (sign x)
      (cond ((= x 0) 0)
            ((> x 0) 1)
            (else -1)))
    (define (make-rat n d)
      (let ((g (gcd n d))
            (frac-sign (* (sign n) (sign d))))
        (cons (* (abs (/ n g)) frac-sign)
              (abs (/ d g)))))
    (define (print-rat x)
      (newline)
      (display (numer x))
      (when (not (= 0 (numer x)))
        (begin (display "/")
               (display (denom x)))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
                   (* (numer y) (denom x)))
                (* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
                   (* (numer y) (denom x)))
                (* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
                (* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
                (* (denom x) (numer y))))
    (define (equal-rat? x y)
      (= (* (numer x) (denom y))
         (* (numer y) (denom x))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
         (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
         (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
         (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
         (lambda (x y) (tag (div-rat x y))))
    (put 'equ? '(rational rational)
         (lambda (x y) (and (eqv? (numer x) (numer y))
                            (eqv? (denom x) (denom y)))))
    (put 'numer '(rational) numer)
    (put 'denom '(rational) denom)
    (put '=zero? '(rational)
         (lambda (x) (and (eqv? (numer x) 0)
                          (not (eqv? (denom x) 0)))))

    (put 'make 'rational
         (lambda (n d) (tag (make-rat n d))))
    'done))