(module apply scheme
  (require "../tag-system/tag-system.ss" "../operations-table/operations-table.ss"
           "../coercion/coercion-table.ss")
  (provide apply-generic)

  (define (apply-generic op . args)
    (define (coerce items dst)
      (if (null? items)
          '()
          (let* ((item (car items))
                 (coercion (coerce-var item
                                       dst)))
            (if (not (null? coercion))
                (cons coercion
                      (coerce (cdr items) dst))
                '(error)))))

   (define (correct-coercion? items)
     (not 
      (ormap (lambda (x) (equal? x 'error)) items)))

   (define (possible-coercions items)
     (define (iter current before after result)
       (let* ((c1 (coerce before current))
              (c2 (coerce after current)))
         (if (and (correct-coercion? c1)
                  (correct-coercion? c2))
             (let ((result (cons (append c1 (cons (coerce-var current current)
                                                  c2))
                                 result)))
               (if (not (null? after))
                 (iter (car after) (append before (list current))
                       (cdr after)
                       result)
                 result))
             (if (not (null? after))
                 (iter (car after)
                       (append before (list current))
                       (cdr after)
                       result)
                 result))))
     (iter (car items) '() (cdr items) '()))

   (define (apply-coercion coercion items)
     (if (null? coercion)
         '()
         (cons ((car coercion) (car items))
               (apply-coercion (cdr coercion) (cdr items)))))

   (let* ((type-tags (map type-tag args))
          (proc (get op type-tags)))
     (if (not (null? proc))
         (apply proc (map contents args))
         (let* ((coercions (possible-coercions args))
                (procs (map (lambda (x) (cons (get op (map type-tag x))
                                              x))
                            coercions))
                (appropriate (filter (lambda (x) (not (null? (car x)))) procs)))
           (if (not (null? appropriate))
               (let* ((args (cdar appropriate))
                      (proc (caar appropriate)))
                 (apply proc (map contents args)))
               (error "Operation for specified (inferred) types not found: "
                      (list op (map type-tag args)))))))))
;;            (error "Coercion for specified arguments not found: "
;;                   (list op type-tags)))))))
